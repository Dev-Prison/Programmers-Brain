                     # 3장

- 사람의 기억은 단순한 계층구조가 아님. → 관련된 여러 개념들이 모두 ‘연결’ 되어 있는 형태
    - 기억은 서로 연관성, 관계성을 갖고 저장된다. ex) python 의 list comprehenssion 문법을 기억하려고 할 때, for 루프 문법을 알고 있었다면 이것의 도움을 받게 되는 것.
- 정기적으로 꾸준히 연습하기 → 당연히..반복할 수록 기억은 강화됨
    - 어느정도 간격을 ‘길게’ 해야 LTM 에 남을 확률 높음.



- 플래시 카드 만들기 : 기억해낼 수 있도록 요청 하는 질문 or 단어(앞면)- 개념에 대한 코드(뒷면) 를 적은 ‘플래시 카드’
    - 앞 or 뒷면 보고 그 반대면에 적힌 것을 생각 해 낼 수 있도록 하는
    - 당연히 반복 해야함
    - why ? ‘능동적으로 기억하려고 (노력) 하는 행위’  → 기억 을 강화  (아래의 인출강도와 관련 )
- 저장강도, 인출 강도
    - 기술 면접 처럼. 머리속에는 있는데, 막상 말로는 안 나오는 것들 —> ‘인출 강도’ 가 낮은 것.
    - **‘저장’ 은 되는데, 필요할 때 가져오지 못하면 무쓸모 → ‘기억을 강화’ 해서 ‘인출강도’를 강화하는게 중요 해 보임**
    - 반복 학습 → 저장강도 강화
    - 이미 알고 있다고 생각 하는 내용을 ***‘기억하려고’ 노력*** —> 인출 강도 강화
        - (이론 보다, 문제를 먼저 푸는 사람들 은 ‘인출 강도 강화’ 를 하고 있는 것 아닐까? )
        - 학습을 추가로 하지 않고, 정보를 기억하려 능등적으로 노력하는 것 만으로도, 배운 것을 많이 기억하였음.
        - ***필요할 때 마다 검색하는 것은 좋은 방법이 아니군*** ( 노력 없이 쉽게 찾음 → 두뇌에서는 이를 기억할 필요가 없다고 느끼게 됨 → 약한 인출 강도로 기억됨 )
        - 다른 기억에 ***연관된 기억  → 높은 인출 강도***
            - 기존 스키마타(기존에 갖고 있는 연관된 기억)  에 맞추어 기억을 저장하는 과정에서, 왜곡되어 저장 되기도 함. —> ex) 내 신념, 가치관에서 A 에 대한 a1,a2,a3 라는 정보 중, “a2 는 별로 중요하지 않은 듯 ㅇㅇ” 라고 생각하고 기억하지 못할 수도 있는 것.
            - 새롭게 기억하고자 하는 내용을, ***이미 LTM 에 저장되어 있는 기억과 연관지으면서 생각할 수록 더 잘*** 기억 할 수 있음

- 연습하기
    - 어떤 다른 개념을 생각나게 하나 ? 모든 관련된 개념 적어보기
    - 답해보기
        - 왜 그 개념을 생각나게 했지?
        - 공통점이 있나?
        - 비슷한 환경에서 사용될 수 있을까?
        - 기존 개념 대신 사용 가능해?
        - 동일한 목적을 위해 사용할 수 있는 다른 방법의 코드 기억해 ? 같은 결과를 내는 비슷한 코드들을 많이 생각해 보자
        - 다른 언어에도 이런 개념이 있나? 그 언어로 이 동작 수행 코드 작성할 수 있어 ? 이 새로운 언어의 코드랑 다른 점이 뭐야 ?
        - 어떤 패러다임, 도메인, 라이브러리 or 프레임워크와 잘 맞을까?

생각해보면 나도 CS 나 , 새로운 문법을 배울 때면, 기존과 어떤 차이점이 있었는지, 그리고 이 개념이 뭐랑 닮았는지를 생각하며 공부하려 했었다. 예를들어 DataBase system 내부가 마치 작은 하나의 운영체제 같다 ( 그 내부에서 사용하는 캐시도 있고, 내부에서 사용하는 락도 있고 … ) 고 생각하며 공부하기도 했었다.

최근에는 너무 생각을 안 하고 살았던 것 같다.

공부 했던 것을 능동적으로 떠올리며 다시 한 번 정리 해 보는 시간을 갖는게 더 어려운게 아닐까 라는 생각도 들었다. 의식적으로 노력해야 할 것 같다.

---

# 4장 - 복잡한 코드를 읽는 방법

- 코드를 읽을 때 이해가 잘 안되고, 뭔가 적어 놓거나, 단계별로 실행 순서를 따라가고 싶은 마음이 드는 것 → 인지부하가 높은 상태
    - 어느 부분이 ‘내재적 인지 부하’ 를 발생, 어느 부분이 ‘외재적 인지부하’ 를 발생시키는지 확인 해 볼 것
        - 내재적 인지 부하 : 그 문제 자체가 갖는 특성 - ex) 가로, 세로 길이가 주어진 삼각형의 빗변의 길이 구하기
            - 코드에 존재하는 복잡성에 기인
        - 외재적 인지 부하 : 문제 자체 외에 추가되는 인지 부하 - ex) 가로는 a 라는 변수, 세로는 b 란는 변수다
            - 코드가 표현되는 방식 or 코드를 읽는 개발자의 지식 부족에 기인.

- 코드가 유발하는 인지 부하를 줄이기 위해 → 나에게 좀 더 친숙한 형태로 ‘리팩토링’ 하자
    - 읽는 사람이 이미 가진 지식이 맞춰 코드를 변경 해 → ‘외재적 인지를 줄이는’ 방식.
    - 책에서는 , 람다, 삼항 연산자 를 풀어 내서 쓰고 있었음.
        - 익명함수, 람다, 삼항연산자는 오히려 가독성 높은 코드를 만들 때 유용한데
        - 이에 대한 개념조차 없다면, 이를 사용할 때 오히려 가독성이 떨어지기에 풀어 쓸 수도 있다고 말하고 있다.
    - ( 내 생각 ) 특히 새로운 언어를 배울 때 이런 일이 많을 것 같다. 그 언어 특유의 문법 대신, 먼저 나에게 친숙한 형태로 작성(나에게 가독성 있는 형태로 리팩토링 )하고 → 후에는 그 문법을 적용한 형태로 다시 리팩토링.   ( 진~짜 시간이 없다면 이렇게 하고, 그렇지 않으면 팀 내에 이 새로운 언어의 문법을 지키도록 컨벤션 만들어 두고, 학습을 먼저 하게 하는게 오히려 낫지 않을까 ㅎ )
- 코드를 여러 번 읽어도 이해가 되지 않는 경우 → 어디에 중점을 두고 읽어야 하는지 모름, 어떤 순서로 읽어야 하는지도 모름. 큰 그림이 이해 되지 않음.
    - 작업 기억 공간의 한계에 다다른 것.
    - 보조 도구들을 사용하자
        - ‘의존 그래프’를 만들어 보자.  —> 처음에 C 언어 배울 때 이와 비슷하게 공부했던 기억이 있음
            - 코드를 찾기 위해 낭비하는 시간을 줄이는데 사용
        - 상태표 사용 → 이것 역시 C 와 같은 언어에서 유용할 듯.. 하나의 변수가 각 단계마다 어떤 상태가 되는지 추적하는게 필요할 듯.
        - ( 내 생각 ) debugging 도구들도 이런 역할을 해 주는 것 같다
