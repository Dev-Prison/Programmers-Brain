# ch09_나쁜코드와 인지 부하를 방지하는 두 가지 프레임워크(??)

> 나쁜 코드와 인지 부하
> 

## 코드 스멜과 인지 부하

코드 스멜은 인지 부하를 초래 한다. 

### 마틴 파울러의 22가지 코드 스멜 소개

| 코드스멜 | 설명 |
| --- | --- |
| 긴 메서드 | 하나의 메서드 - 너무 여러가지 일을 하느라 길어져선 안됨 |
| 많은 인수 | 메서드 인수는 많은면 안됨 |
| switch 문 | 스위치 문이 길어지는거 안좋음 
다형성으로 해결 |
| 비슷한 클래스 | 다른 것 처럼 생겼으나, 유사한 .. 그런 클래스는 있으면 안된다 ( 아마 어떤 클래스를 써야 할지부터도 혼란이 올 거고, 책임의 분리도 혼란스러워질 듯 ) |
| 원시 타입 집착 | 과도한 원시 타입 집착 피하기 (VO 를 사용하는 것을 권장하는걸까?) |
| 미완성 라이브러리 클래스 | 메서드를 라이브러리 클래스가 아닌 임의의 클래스에 추가해선 안됨 |
| 너무 큰 클래스 | 너무 많은 필드, 메서드, 너무 많은 일을 하는 것.
클래스가 제공하는 추상화를 불명확하게 만드는 것이다 |
| 게으른 클래스 | 하는 일이 너무 적어서도 안됨 |
| 데이터 클래스 | 데이터만 가져서는 안됨. 메서드도 가져야 한다. |
| 임시 필드 | 현재 불필요한 필드를 임시로 가져선 안된다 ( 필요할 때 만드는게 좋을 듯. 이렇게 임시로 만들어진 애를 보고, 다른 사람들은 이게 사용되고 있지 않음에도 망설이면서 지우지도 못할 수도 있음) |
| 데이터 그룹 | 같이 사용되는 데이터들은, 같은 클래스에 저장 |
| 산재한 수정 | 코드 수정은 ‘하나의 클래스, 한 부분’ 에서 이루어져야 한다 (응집도) |
| 기능 이전 | B 클래스에서 A 클래스의 많은 부분들을 참조하고 있다면, 그 메서드들은 B 클래스로 옮겨져야 하는 부분 일지도? |
| 부적절한 연관 | 다른 클래스에 광범위하게 연관되지 않아야 한다 |
| 중복 | 비슷한 코드가 여러 군데에 중복되면 안됨 |
| 주석문 | “무엇”을 하는 코드인지 를 설명하는게 아니라!, 왜 이 코드가 여기에 있는지를 설명하는 정도 |
| 메시지 체인 | 길게 체이닝 되어선 안된다 |
| 미들맨 | 클래스 자신은 하는 일이 없이
위임을 계속하고 있다면, 이 클래스가 굳이 존재할 이유가 있는가?
 |
| 평행 상속 | A 클래스의 서브클래스를 만들 때 마다 B 클래스의 서브클래스도 만들어야 한다면, 두 클래스의 기능은 하나의 클래스로 합쳐야 하는 기능일 거임 |
| 상속 거절 | 자신이 사용하지 않을 것도 상속받는 상황이라면, 상속은 필요 없는 일일지도? |
| 샷건 수술 | 코드 수정은 한 클래스에서만 이루어져야 한다. 
하나의 수정에 여러 클래스를 수정해야 한다? 구조 문제 (응집도) |
| 추측에 근거한 일반성 | 만일의 경우를 대비한 코드를 추가하지 말고, 필요한 기능만 추가해라 ( 예전의 많은 오버엔지니어링이 떠오름 )  |
- God Method
    - 너무 많은 일을 하는, 너무 긴 메서드
- God class
    - 너무 많은 일을 하는, 너무 큰 클래스
    - 우리는 의미 있는 이름과, 별도의 작은 기능을 가진 클래스로 나누는 것을 선호.
- 게으른 클래스
    - 너무 적은 일을 하는 클래스
    - 껍데기만 만들어뒀던 경우 (나중에 상속이나, 구현 시키려고) - 그리고는 아무것도 하지 않은 그런 경우의 부산물
- 코드 중복 → 비슷해 보이는 코드들 때문에, “차이”를 파악하려고 엄청 집중해서 봐야함
    
    ```kotlin
    int foo(int i) {
    	if(i > 0 ) {
    		return i;
    	return ++i;
    }
    int goo(int i) {
    	if(i > 0 ) {
    		return i;
    	return i+2;
    }
    ```
    
- 긴 매개변수 목록, 복잡한 스위치문
    - 기억 공간의 과부하 유발
    - 매개변수를 다 외우지도 못함 (물론 관련된거는 청크 단위로 기억나겠지만- xOrigin, yOriign, xDestination, yDestination )
    - 스위치문 역시.. 각 case 들이 뭔지 기억하려고 노력하고 있게 됨

## 언어적 안티패컨

- 이름은 혼동을 불러온다

| 이름이 나타내는 것 보다 “더 많은 일” 을 하는 메서드 |
| --- |
| 이름이 나타내는 것 보다 “더 적은 일” 을 하는 메서드 |
| 이름과 “정반대 일” 을 하는 메서드 |
| 실제 포함된 것 보다, 더 많은 것을 가진 것 처럼 보이는 식별자 이름 |
| 포함된 것을 누락하는 식별자 이름  |
| 포함된 것과 반대되는 식별자 이름 |
- 또 다른 예시들
    - setter 인데, set 뿐만 아니라 뭔가를 return 까지 하는 메서드
    - 주석이나 이름이 실제와 다른
    - isXXXX 인데 boolean 타입이 아닌 경우
- 이런 인지 부하들 측정
    - 파스 척도
    - 눈, 피부, 뇌 등을 기반으로 측정도 가능
        - 와닿았던 내용 : 어려운 일을 할 수록 시각적 자극을 최대한 많이 받아들이려고 눈을 깜빡이지 않고 동공은 확장됨.

> 익숙하지 않은 내용을 읽을 때면, ex)이름 을 보고는 LTM 에서 이와 관련된 경험을 검색할 것인데, 이 때 ‘이름’이 실제 하는 일과 충돌되는 것을 나타내고 있었다면? 애초에 잘못된 정보가 주어져 버리는 것 —- ex) retriveElements() 라는 메서드를 보고는 ‘단일 원소’ 와는 관련 없을 거라고 생각하고, 컬렉션을 받나보다 생각했는데, 단일 원소가 리턴되어버리는 것.
> 

# ch10_복잡한 문제 해결을 더 잘하려면

> 자동화 : 작은 것에 시간을 적게 쓸 수록, 어려운 것을 더 쉽게 풀 수 있기에 필요함.
> 

## 문제 해결이란 ?

- “시작 상태” 에서 시작해, 여러 단계의 상태 공간들을, 최적의 방식으로 탐색해 “목적상태” 에 도달 하는 것.
    - 코드 작성에서, 이 목표 상태에 도달함을 확인하는 방법은 무엇일까? ex)테스트 코드, 실제로 실행시키고 테스트 하는 것.

## 문제 해결에서 LTM, STM 은 어떤 역할?

- 문제를 풀 때면, “목표 상태” 와 “적용규칙” 에 대한 “지식” 들을 염두에 둔다.
- 사전 지식은 해결책에 영향을 미친다.
    - 문제에 대해 생각하는 동안 LTM 에서 정보를 인출한다.
    - LTM 으로부터 올바른 기억 인출을 위한 단서가 필요 - 단서가 구체적일 수록 올바른 기억 찾을 가능 성 높음.
- 문제에 대해서 생각하는 동안, “문제의 상황에 대한 정보” 들은 STM 으로부터 가져온다.

### 암시적, 선언적 기억

- 암시적 기억 : 의식하지 않고 발휘되는 기억
- 선언적 기억
    - 일화적 기억 : 우리가 일반적으로 생각하는 ‘기억’ 의 정의 - ex) 15살에 이사를 왔지
    - 의미적 기억 : 개념, 사실

( 역시, 기억을 위해 ‘많이 생각해야’ 만 ‘인출 강도’ 가 높아진다 ) 

- 일화적 기억 의 사용
    - 전문가들은 익숙한 문제를 해결하기보다는 ‘재현’ 한다.
        - 유사한 문제에 효과가 있었던 해결책에 의존한다.
- 암시적 기억의 사용
    - 이전에 풀었던 것과 비슷한 문제를 풀 때 ‘직감’이 발휘된다.
    - 어떻게 해야 하는지 아는 것 보다는, 무엇을 해야 하는지 알고 있는 것이다.
    - 신속함에 도움됨.
    - 하지만 새로운 것을 배울 때는 방해가 되기도 ( Java 를 쓰려다 Kotlin 을 쓰려니 자꾸 필요없는 semicolon 을 붙이네 )

## 자동화 : 암시적 기억의 생성

암시적 기억이 많을 수록 인지 부하를 줄일 수 있다.

- 어떻게 이를 만들 수 있을까?
    - 플래시 카드 - 선언 적 지식에 유용한 방법
    - 인지 → 연상 → 자율 단계
        - 인지 : 새로운 것을 배우는 단계. ( index 개념을 처음 배울 때 - 아 1이 아닌 0부터 시작하는 구나 )
        - 연상 : 새 정보를 적극적으로 반복. → 이 정보를 사용해 조치를 취해 효과적이었다면, 기억된다. ( index 라는 것은 일반적인 숫자 -1 으로 생각하면 되겠다)
        - 자율 : 명시적으로 생각 안하고도 자동으로 나오는 것 . 자동화의 경지.
- 자동화 되면 왜 신속해지나 ?
    - 인스턴스 기억’이 많을 수록, 이전의 방법을 기억하고, 동일 방법 적용 가능.
    - 기억을 인출하다 보면 자동화가 된다.
    - 부족하면 ‘추론’ 을 하게 됨.
        - 추론을 하지 않고, 순간적으로! 기억에 의존하면 자동화는 완전해진 것.
- 자동화를 위한 연습 : 암시적 기억 개선
    - 의도적으로 반복 연습
        - 유사하지만 ‘다른’ 프로그램을 많이 작성
        - 복잡한 프로그램을 ‘수정’ 함으로서, 내가 이미 알고 있던 개념과 어떻게 다른지 차이점에 대해 ‘스스로 생각’ 해 볼 수 있게 됨.

## 본유적 부하

A 문제에 대한 답안지를 받은 그룹이 A 문제 뿐만 아니라 새로운 문제 B 도 더 빠르게 풀었다. 

- 스스로 끝까지 붙잡고 있는게 해답은 아님을 보여주는 예시
- 왜 이런 일이 ?
    - 작업 기억 공간(CPU) 이 다차면, 제대로 생각을 할 수 없게 되어버림…
        - 어떤 일을 할 때, ‘일부 정보는 LTM 에 저장하는 과정’ 도 같이 일어나고 있는데
        - 작업 기억 공간의 부하로, “LTM 에 정보 저장하기’ 도 안 일어나게 되어버린 것.
        - 해결책을 저장할 수 없을 정도로 몰입해 버린 것…

( 삽질도 너무 오래 하는게 역시 답은 아닌 듯 )
